from .base import DyGraphTask
import numpy as np
import re
import os

# Helper function: Simulate graph evolution to get final state
# Ported and modified from get_final_state in evaluate_2.py


# Helper function: Apply operation sequence generated by model
# Ported and modified from apply_result_sequence in evaluate_2.py
def apply_reverse_sequence(initial_edges, result_quadruples):
    """
    Apply the operation sequence generated by LLM to the given initial edge set.

    Args:
        initial_edges (set): Initial edge set { (u, v), ... } (normalized tuples).
        result_quadruples (list): List of quadruples parsed from LLM result [(u, v, t, op), ...] (int, int, int, str).

    Returns:
        set: Final edge set after applying the operation sequence.
    """
    quad_list = initial_edges+result_quadruples
    quad_list = sorted(quad_list, key=lambda x: (x[2], 0 if x[3] == 'a' else 1))
    print(quad_list)
    simulated_edges = set()
    for u, v, t, op in quad_list:
        edge = tuple(sorted((u, v)))
        if op == 'a':
            simulated_edges.add(edge)
        elif op == 'd':
            simulated_edges.discard(edge)
    print(simulated_edges)
    return simulated_edges

# Helper function: Parse quadruple list from response content (reused from WhatEdgeAtTime)
def parse_quadruples_from_list_string(list_string):
    """Parse quadruple list from string in list format, supports multiple formats"""
    quadruples = [] # Return list because order may be important (although not important during apply)
    
    # Strategy 1: Try to parse nested list format [[1, 5, 0, "d"], [5, 6, 1, "d"], ...]
    nested_pattern = r'\[\s*(?:\[\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*[\'"]?[ad][\'"]?\s*\]\s*,?\s*)+\]'
    nested_match = re.search(nested_pattern, list_string)
    if nested_match:
        nested_content = nested_match.group(0)
        # Extract each sublist
        sub_lists = re.findall(r'\[\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*[\'"]?([ad])[\'"]?\s*\]', nested_content)
        for u, v, t, op in sub_lists:
            try:
                quad = (int(u), int(v), int(t), op)
                quadruples.append(quad)
            except ValueError:
                print(f"  Warning (ReverseGraph - Parsing): Skipping nested list element with parsing error: {(u, v, t, op)}")
        return quadruples
    
    # Strategy 2: Try to parse tuple format [(1, 5, 0, "d"), (5, 6, 1, "d"), ...]
    tuple_matches = re.findall(r'\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*[\'"]?([ad])[\'"]?\s*\)', list_string)
    for t in tuple_matches:
        try:
            quad = (int(t[0]), int(t[1]), int(t[2]), t[3])
            quadruples.append(quad)
        except ValueError:
             print(f"  Warning (ReverseGraph - Parsing): Skipping tuple with parsing error: {t}")
    return quadruples


class DyGraphTaskReverseGraph(DyGraphTask):
    """
    Task: Find the operation sequence that can reverse the dynamic graph from its final state back to an empty graph.
    Corresponds to original scripts: How.py, evaluate_2.py
    """
    def generate_qa(self, info, *args, **kwargs):
        """
        Generate QA pairs. The 'answer' for this task is special, evaluation is based on whether the graph is empty after applying the model output.
        We pre-calculate the final state of the graph in QA for convenient evaluation.
        """
        context_orig = info['edge_index']
        # Type conversion and sorting
        context_typed = []
        for item in context_orig:
            try:
                u, v, t, op = item
                context_typed.append((int(u), int(v), int(t), str(op)))
            except ValueError as e:
                print(f"Warning (ReverseGraph - QA): Skipping unparseable line: {item} - {e}")
                continue
            except Exception as e:
                print(f"Warning (ReverseGraph - QA): Error processing line: {item} - {e}")
                continue

        if not context_typed:
             print("Error (ReverseGraph - QA): No valid context data.")
             return None


        qa = {
            "context": context_orig, # Original format context
            "query": None,          # query is empty, question is fixed
            "answer": None,         # answer is empty, evaluation doesn't directly compare answers
            "task": self.task
        }
        return qa

    def generate_instructor_task(self, *args, **kwargs):
        # Transplanted from How.py
        return (f"Your task is to answer what is one possible sequence of quadruple operations that reverse the dynamic graph from the final time to empty?")

    def generate_instructor_answer(self, *args, **kwargs):
        # Transplanted from How.py
        return "Give the answer as a list of 4-tuples at the end of your response after 'Answer:'."

    def generate_prompt_examplars(self, num, *args, **kwargs):
            # Transplanted from How.py, ensure correct format
            qa_examples_raw = [
                (
                  [(1, 2, 0, 'a'), (1, 2, 1, 'd'), (2, 3, 3, 'a'), (0, 3, 4, 'a'), (2, 3, 4, 'd')],
                  None, # query
                    """**Chain of Thought:**
1. Objective: Transform the input list of dynamic graph operations by reversing each operation type and then reversing the entire sequence of operations.
2. Reverse Operations: Iterate through each 4-tuple (u, v, t, op_type) in the original edge list.
    * If op_type is 'a', change it to 'd'.
    * If op_type is 'd', change it to 'a'.
    * Keep u, v, and t the same for each tuple.
3. Reverse Sequence: Take the new list of transformed tuples and arrange them in reverse order. The last tuple becomes the first, the second to last becomes the second, and so on.
4. Final Output: Present the newly ordered list of 4-tuples as the result.""",  
                 [(2, 3, 4, 'a'), (0, 3, 4, 'd'), (2, 3, 3, 'd'), (1, 2, 1, 'a'), (1, 2, 0, 'd')]
                )
            ]


#[(0, 7, 0, a), (0, 9, 1, a), (1, 8, 1, a), (2, 8, 1, a), (0, 3, 2, a), (1, 8, 2, d), (8, 9, 2, a), (0, 5, 3, a), (0, 9, 3, d), (4, 9, 3, a), (6, 9, 3, a), (8, 9, 3, d), (0, 3, 4, d), (0, 5, 4, d), (3, 5, 4, a), (4, 9, 4, d), (5, 6, 4, a)]             
#[(5, 6, 4, d), (4, 9, 4, a), (3, 5, 4, d), (0, 5, 4, a), (0, 3, 4, a), (8, 9, 3, a), (6, 9, 3, d), (4, 9, 3, d), (0, 9, 3, a), (0, 5, 3, d), (8, 9, 2, d), (1, 8, 2, a), (0, 3, 2, d), (2, 8, 1, d), (1, 8, 1, d), (0, 9, 1, d), (0, 7, 0, d)]
            # Convert format - Fix: correctly handle 4 elements
            qa_formatted = [ [list(c), q, s, list(a)] for c, q, s, a in qa_examples_raw]
            return self.make_qa_example(num, qa_formatted)


    def generate_prompt_question(self, query = None, *args, **kwargs):
        # Transplanted from How.py, question is fixed, only depends on context
        # context is already handled in generate_context_prompt
        return f" What is one possible sequence of quadruple operations that reverse the dynamic graph from the final time to empty?"

    def evaluate(self, qa, response, use_agent):
        """
        Evaluate model response. Transplanted from evaluate_2.py.
        Get the final state of the graph, apply the operation sequence generated by the model, check if the resulting graph is empty.
        Supports multiple formats:
        1. "Answer: [(1, 5, 0, 'd'), (5, 6, 1, 'd')]"
        2. "[(1, 5, 0, 'd'), (5, 6, 1, 'd')]" (direct list format)
        Return value:
            metric: 1 (correct, graph is empty), 0 (incorrect, graph is not empty), -1 (unable to parse format or QA data error)
            extracted_answer: Parsed quadruple list or None
        """
        final_original_edges = qa.get("context")
        predicted_quads_list = None
        
        # Strategy 1: Find content after the last "Answer:"
        answer_marker = "Answer:"
        answer_start_index = response.rfind(answer_marker)
        if answer_start_index != -1:
            extracted_part = response[answer_start_index + len(answer_marker):].strip()
            # Try to parse list content
            predicted_quads_list = parse_quadruples_from_list_string(extracted_part)

        # Strategy 2: If "Answer:" marker not found or parsing failed, parse the entire response directly
        if predicted_quads_list is None or len(predicted_quads_list) == 0:
            predicted_quads_list = parse_quadruples_from_list_string(response)

        if predicted_quads_list is not None and len(predicted_quads_list) >= 0: # Parsing successful (may be empty list)
            # Apply the operation sequence generated by the model
            final_simulated_edges = apply_reverse_sequence(final_original_edges, predicted_quads_list)

            # Determine if the resulting graph is empty
            if len(final_simulated_edges) == 0:
                metric = 1 # Correct
                print(f"  Evaluation: Correct - Graph became empty.")
            else:
                metric = 0 # Incorrect
                print(f"  Evaluation: Incorrect - Graph did not become empty. Remaining edges: {final_simulated_edges}")
            return metric, predicted_quads_list
        else:
            # Parsing returns None
            return -1, None # Format error