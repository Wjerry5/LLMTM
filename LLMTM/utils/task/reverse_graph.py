from .base import DyGraphTask
import numpy as np
import re
import os

# Helper function: Simulate graph evolution to get the final state
# Ported and modified from evaluate_2.py's get_final_state


# Helper function: Apply the operation sequence generated by the model
# Ported and modified from evaluate_2.py's apply_result_sequence
def apply_reverse_sequence(initial_edges, result_quadruples):
    """
    Applies the operation sequence generated by the LLM to the given initial set of edges.

    Args:
        initial_edges (set): The initial set of edges { (u, v), ... } (normalized tuple).
        result_quadruples (list): List of quadruples parsed from LLM result [(u, v, t, op), ...] (int, int, int, str).

    Returns:
        set: The final set of edges after applying the operation sequence.
    """
    quad_list = initial_edges+result_quadruples
    quad_list = sorted(quad_list, key=lambda x: (x[2], 0 if x[3] == 'a' else 1))
    print(quad_list)
    simulated_edges = set()
    for u, v, t, op in quad_list:
        edge = tuple(sorted((u, v)))
        if op == 'a':
            simulated_edges.add(edge)
        elif op == 'd':
            simulated_edges.discard(edge)
    print(simulated_edges)
    return simulated_edges

# Helper function: Parse list of quadruples from response content (reused from WhatEdgeAtTime)
def parse_quadruples_from_list_string(list_string):
    """Parses a list of quadruples from a list-formatted string, supports multiple formats"""
    quadruples = [] # Return a list here, as order might matter (though not for apply)
    
    # Strategy 1: Try parsing nested list format [[1, 5, 0, "d"], [5, 6, 1, "d"], ...]
    nested_pattern = r'\[\s*(?:\[\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*[\'"]?[ad][\'"]?\s*\]\s*,?\s*)+\]'
    nested_match = re.search(nested_pattern, list_string)
    if nested_match:
        nested_content = nested_match.group(0)
        # Extract each sublist
        sub_lists = re.findall(r'\[\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*[\'"]?([ad])[\'"]?\s*\]', nested_content)
        for u, v, t, op in sub_lists:
            try:
                quad = (int(u), int(v), int(t), op)
                quadruples.append(quad)
            except ValueError:
                print(f"  Warning (ReverseGraph - Parse): Skipping incorrectly parsed nested list element: {(u, v, t, op)}")
        return quadruples
    
    # Strategy 2: Try parsing tuple format [(1, 5, 0, "d"), (5, 6, 1, "d"), ...]
    tuple_matches = re.findall(r'\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*[\'"]?([ad])[\'"]?\s*\)', list_string)
    for t in tuple_matches:
        try:
            quad = (int(t[0]), int(t[1]), int(t[2]), t[3])
            quadruples.append(quad)
        except ValueError:
             print(f"  Warning (ReverseGraph - Parse): Skipping incorrectly parsed tuple: {t}")
    return quadruples


class DyGraphTaskReverseGraph(DyGraphTask):
    """
    Task: Find a possible sequence of operations that reverses the dynamic graph from its final state back to an empty graph.
    Corresponds to original scripts: How.py, evaluate_2.py
    """
    def generate_qa(self, info, *args, **kwargs):
        """
        Generates QA pairs. The 'answer' for this task is special; evaluation sees if the graph becomes empty after applying the model output.
        We pre-calculate the final state of the graph in QA for easy evaluation.
        """
        context_orig = info['edge_index']
        # Type conversion and sorting
        context_typed = []
        for item in context_orig:
            try:
                u, v, t, op = item
                context_typed.append((int(u), int(v), int(t), str(op)))
            except ValueError as e:
                print(f"Warning (ReverseGraph - QA): Skipping unparseable row: {item} - {e}")
                continue
            except Exception as e:
                print(f"Warning (ReverseGraph - QA): Error processing row: {item} - {e}")
                continue

        if not context_typed:
             print("Error (ReverseGraph - QA): No valid context data.")
             return None

        # Calculate the set of edges in the final state
        final_edges_set = get_final_state_edges(context_typed)

        qa = {
            "context": context_orig, # Context in original format
            "query": None,           # query is empty, question is fixed
            "answer": None,          # answer is empty, evaluation doesn't compare answer directly
            "_final_edges_set": final_edges_set, # Store final state for evaluation
            "task": self.task
        }
        return qa

    def generate_instructor_task(self, *args, **kwargs):
        # Ported from How.py
        return (f"Your task is to answer what is one possible sequence of quadruple operations that reverse the dynamic graph from the final time to empty?")

    def generate_instructor_answer(self, *args, **kwargs):
        # Ported from How.py
        return "Give the answer as a list of 4-tuples at the end of your response after 'Answer:'."

    def generate_prompt_examplars(self, num, *args, **kwargs):
            # Ported from How.py, ensure format is correct
            qa_examples_raw = [
                (
                  [(1, 2, 0, 'a'), (1, 2, 1, 'd'), (2, 3, 3, 'a'), (0, 3, 4, 'a'), (2, 3, 4, 'd')],
                  None, # query
                    """**Chain of Thought:**
1. Objective: Transform the input list of dynamic graph operations by reversing each operation type and then reversing the entire sequence of operations.
2. Reverse Operations: Iterate through each 4-tuple (u, v, t, op_type) in the original edge list.
    * If op_type is 'a', change it to 'd'.
    * If op_type is 'd', change it to 'a'.
    * Keep u, v, and t the same for each tuple.
3. Reverse Sequence: Take the new list of transformed tuples and arrange them in reverse order. The last tuple becomes the first, the second to last becomes the second, and so on.
4. Final Output: Present the newly ordered list of 4-tuples as the result.""",  # CoT - for compatibility with base.py's 4-element format
                  [(2, 3, 4, 'a'), (0, 3, 4, 'd'), (2, 3, 3, 'd'), (1, 2, 1, 'a'), (1, 2, 0, 'd')]
                )
            ]


#[(0, 7, 0, a), (0, 9, 1, a), (1, 8, 1, a), (2, 8, 1, a), (0, 3, 2, a), (1, 8, 2, d), (8, 9, 2, a), (0, 5, 3, a), (0, 9, 3, d), (4, 9, 3, a), (6, 9, 3, a), (8, 9, 3, d), (0, 3, 4, d), (0, 5, 4, d), (3, 5, 4, a), (4, 9, 4, d), (5, 6, 4, a)]               
#[(5, 6, 4, d), (4, 9, 4, a), (3, 5, 4, d), (0, 5, 4, a), (0, 3, 4, a), (8, 9, 3, a), (6, 9, 3, d), (4, 9, 3, d), (0, 9, 3, a), (0, 5, 3, d), (8, 9, 2, d), (1, 8, 2, a), (0, 3, 2, d), (2, 8, 1, d), (1, 8, 1, d), (0, 9, 1, d), (0, 7, 0, d)]
            # Convert format - Fix: correctly handle 4 elements
            qa_formatted = [ [list(c), q, s, list(a)] for c, q, s, a in qa_examples_raw]
            return self.make_qa_example(num, qa_formatted)


    def generate_prompt_question(self, query = None, *args, **kwargs):
        # Ported from How.py, question is fixed, only depends on context
        # context is already handled in generate_context_prompt
        return f" What is one possible sequence of quadruple operations that reverse the dynamic graph from the final time to empty?"

    def evaluate(self, qa, response):
        """
        Evaluates the model response. Ported from evaluate_2.py.
        Gets the final state of the graph, applies the model-generated operation sequence, checks if the resulting graph is empty.
        Supports multiple formats:
        1. "Answer: [(1, 5, 0, 'd'), (5, 6, 1, 'd')]"
        2. "[(1, 5, 0, 'd'), (5, 6, 1, 'd')]" (Direct list format)
        Returns:
            metric: 1 (correct, graph is empty), 0 (wrong, graph is not empty), -1 (cannot parse format or QA data error)
            extracted_answer: The parsed list of quadruples or None
        """
        final_original_edges = qa.get("context")
        predicted_quads_list = None
        
        # Strategy 1: Find content after the last "Answer:"
        answer_marker = "Answer:"
        answer_start_index = response.rfind(answer_marker)
        if answer_start_index != -1:
            extracted_part = response[answer_start_index + len(answer_marker):].strip()
            # Try to parse list content
            predicted_quads_list = parse_quadruples_from_list_string(extracted_part)

        # Strategy 2: If "Answer:" marker not found or parsing failed, parse the entire response
        if predicted_quads_list is None or len(predicted_quads_list) == 0:
            predicted_quads_list = parse_quadruples_from_list_string(response)

        if predicted_quads_list is not None and len(predicted_quads_list) >= 0: # Parsing successful (could be an empty list)
            # Apply the model-generated operation sequence
            final_simulated_edges = apply_reverse_sequence(final_original_edges, predicted_quads_list)

            # Check if the resulting graph is empty
            if len(final_simulated_edges) == 0:
                metric = 1 # Correct
                print(f"  Evaluation: Correct - Graph became empty.")
            else:
                metric = 0 # Incorrect
                print(f"  Evaluation: Incorrect - Graph did not become empty. Remaining edges: {final_simulated_edges}")
            return metric, predicted_quads_list
        else:
            # Parsing returned None
            return -1, None # Format error